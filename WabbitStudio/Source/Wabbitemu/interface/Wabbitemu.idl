import "oaidl.idl";
import "ocidl.idl";

interface IPage;

[
	uuid(36AE85E8-FE2A-41bc-85B5-105B32D8E181)
]
struct TIApplication
{
	BSTR Name;
	IPage *Page;
	int PageCount;
};

enum SYMBOLTYPE
{
	SYM_REAL = 0x00,
	SYM_LIST = 0x01,
	SYM_MAT = 0x02,
	SYM_EQU = 0x03,
	SYM_STRNG = 0x04,
	SYM_PROG = 0x05,
	SYM_PROTPROG = 0x06,
	SYM_PICT = 0x07,
	SYM_GDB = 0x08,
	SYM_UNKNOWN = 0x09,
	SYM_UNKNOWNEQU = 0x0A,
	SYM_NEWEQU = 0x0B,
	SYM_CPLX = 0x0C,
	SYM_CLIST = 0x0D,
	SYM_UNDEF = 0x0E,
	SYM_WINDOW = 0x0F,
	SYM_ZSTO = 0x10,
	SYM_TBLRNG = 0x11,
	SYM_LCD = 0x12,
	SYM_BACKUP = 0x13,
	SYM_APP = 0x14,
	SYM_APPVAR = 0x15,
	SYM_TEMPPROG = 0x16,
	SYM_GROUP = 0x17,
	SYM_EQUOB = 0x23,

	SYM_NONE = -1,
};

/*
[
	uuid(010A714D-CADA-400f-90F9-FC34B2A20752)
]
struct TISymbol {
	enum SYMBOLTYPE Type;
	BYTE Version;
	WORD Address;
	BYTE Page;
	BSTR Name;
};
*/

[
	uuid(023D1C58-C323-43a7-860B-95FB9C204F91),
	dual,
]
interface ILCD : IDispatch
{
	[propget] HRESULT Display([out, retval] SAFEARRAY(BYTE) *Display);
}

[
	uuid(41C7B7BF-D390-4ba0-8075-462FD3565225),
	dual,
]
interface IZ80 : IDispatch
{
	[propget] HRESULT AF([out, retval] WORD *AF);
	[propget] HRESULT A([out, retval] BYTE *A);
	[propget] HRESULT F([out, retval] BYTE *F);
	[propput] HRESULT AF([in] WORD AF);
	[propput] HRESULT A([in] BYTE A);
	[propput] HRESULT F([in] BYTE F);

	[propget] HRESULT BC([out, retval] WORD *BC);
	[propget] HRESULT B([out, retval] BYTE *B);
	[propget] HRESULT C([out, retval] BYTE *C);
	[propput] HRESULT BC([in] WORD BC);
	[propput] HRESULT B([in] BYTE B);
	[propput] HRESULT C([in] BYTE C);

	[propget] HRESULT DE([out, retval] WORD *DE);
	[propget] HRESULT D([out, retval] BYTE *D);
	[propget] HRESULT E([out, retval] BYTE *E);
	[propput] HRESULT DE([in] WORD DE);
	[propput] HRESULT D([in] BYTE D);
	[propput] HRESULT E([in] BYTE E);

	[propget] HRESULT HL([out, retval] WORD *HL);
	[propget] HRESULT H([out, retval] BYTE *H);
	[propget] HRESULT L([out, retval] BYTE *L);
	[propput] HRESULT HL([in] WORD HL);
	[propput] HRESULT H([in] BYTE H);
	[propput] HRESULT L([in] BYTE L);

	[propget] HRESULT AFP([out, retval] WORD *AFP);
	[propget] HRESULT AP([out, retval] BYTE *AP);
	[propget] HRESULT FP([out, retval] BYTE *FP);
	[propput] HRESULT AFP([in] WORD AFP);
	[propput] HRESULT AP([in] BYTE AP);
	[propput] HRESULT FP([in] BYTE FP);

	[propget] HRESULT BCP([out, retval] WORD *BCP);
	[propget] HRESULT BP([out, retval] BYTE *BP);
	[propget] HRESULT CP([out, retval] BYTE *CP);
	[propput] HRESULT BCP([in] WORD BCP);
	[propput] HRESULT BP([in] BYTE BP);
	[propput] HRESULT CP([in] BYTE CP);

	[propget] HRESULT DEP([out, retval] WORD *DEP);
	[propget] HRESULT DP([out, retval] BYTE *DP);
	[propget] HRESULT EP([out, retval] BYTE *EP);
	[propput] HRESULT DEP([in] WORD DEP);
	[propput] HRESULT DP([in] BYTE DP);
	[propput] HRESULT EP([in] BYTE EP);

	[propget] HRESULT HLP([out, retval] WORD *HLP);
	[propget] HRESULT HP([out, retval] BYTE *HP);
	[propget] HRESULT LP([out, retval] BYTE *LP);
	[propput] HRESULT HLP([in] WORD HLP);
	[propput] HRESULT HP([in] BYTE HP);
	[propput] HRESULT LP([in] BYTE LP);

	[propget] HRESULT IX([out, retval] WORD *IX);
	[propget] HRESULT IXH([out, retval] BYTE *IXH);
	[propget] HRESULT IXL([out, retval] BYTE *IXL);
	[propput] HRESULT IX([in] WORD IX);
	[propput] HRESULT IXH([in] BYTE IXH);
	[propput] HRESULT IXL([in] BYTE IXL);

	[propget] HRESULT IY([out, retval] WORD *IY);
	[propget] HRESULT IYH([out, retval] BYTE *IYH);
	[propget] HRESULT IYL([out, retval] BYTE *IYL);
	[propput] HRESULT IY([in] WORD IY);
	[propput] HRESULT IYH([in] BYTE IYH);
	[propput] HRESULT IYL([in] BYTE IYL);

	[propget] HRESULT PC([out, retval] WORD *PC);
	[propput] HRESULT PC([in] WORD PC);

	[propget] HRESULT SP([out, retval] WORD *SP);
	[propput] HRESULT SP([in] WORD SP);

};

[
	object,
	uuid(B61370EF-8BEF-4bb9-AF88-FF7FFD0A012E),
	pointer_default(unique),
	dual,
]
interface IPage : IDispatch
{
	[id(0), propget, helpstring("Index of this page")]
	HRESULT Index([out, retval] int *pIndex);

	[id(1), propget, helpstring("Whether or not the page is flash")]
	HRESULT IsFlash([out, retval] VARIANT_BOOL *IsFlash);

	[id(2), helpstring("Read from this page within addresses 0 - 16383")]
	HRESULT Read([in] WORD Address, [in] VARIANT ByteCount, [out, retval] VARIANT *Value);

	[id(3), helpstring("Write to this page within addresses 0 - 16383")]
	HRESULT Write([in] WORD Address, [in] VARIANT Value);
}

[
	uuid(9BD2CC22-5E1D-41c1-A134-F24410EF6301),
	dual,
]
interface IKeypad : IDispatch
{
	typedef enum Calc_Key
	{
		KEY_UP,
		KEY_LEFT,
		KEY_RIGHT,
		KEY_DOWN,

		KEY_2ND,
		KEY_ALPHA,
		KEY_MODE,
		KEY_DEL,
		KEY_XTON,
		KEY_STAT,

		KEY_YEQU,
		KEY_WINDOW,
		KEY_ZOOM,
		KEY_TRACE,
		KEY_GRAPH,

		KEY_MATH,
		KEY_APPS,
		KEY_PRGM,
		KEY_VARS,
		KEY_CLEAR,

		KEY_ON,


	} Calc_Key;

	HRESULT PressKey([in] enum Calc_Key Key);
	HRESULT ReleaseKey([in] enum Calc_Key Key);
	HRESULT IsKeyPressed([in] enum Calc_Key Key, [out, retval] VARIANT_BOOL *IsPressed);
	HRESULT PressVirtKey([in] int Key);
	HRESULT ReleaseVirtKey([in] int Key);
}

[
	uuid(59fc4b09-d16b-4f00-b240-7741da7dde5a),
	object,
]
interface IPio : IUnknown
{

}

interface IWabbitemu;

[
	uuid(A24DA6E6-BD47-444d-891F-BB368872C34F),
	pointer_default(unique),
	dual,
	version(1.0)
]
interface ICalcAddress : IDispatch
{
	HRESULT Initialize([in] IWabbitemu *Calc, [in] VARIANT_BOOL IsFlash, [in] int Page, [in] WORD Address);
	// Properties
	[propget, helpstring("Calculator this address is on")]
	HRESULT Calc([out, retval] IWabbitemu **Calc);

	[propget, helpstring("Page this address is on")]
	HRESULT Page([out, retval] IPage **Page);

	[propget, helpstring("The memory address")]
	HRESULT Address([out, retval] WORD *Address);

	// Methods
	[helpstring("Read from this address")]
	HRESULT Read([in, optional] VARIANT Count, [out, retval] VARIANT *Value);
	[helpstring("Write to this address")]
	HRESULT Write([in] VARIANT Value);
}

[
	object,
	uuid(8E5D1F9E-C487-48c9-A1AD-C9ACE44C1E3A),
	pointer_default(unique),
	dual,
	version(1.0)
]
interface ILabel : ICalcAddress
{
	[propget, helpstring("Name of this label")]
	HRESULT Name([out, retval] BSTR *Name);
}


[
	uuid(207CC027-41EE-4582-8430-C1D4FE910143),
	pointer_default(unique),
	dual,
	version(1.0)
]
interface ILabelServer : IDispatch
{
	// Properties
	[propget, helpstring("Whether or not lookups are case sensitive")]
	HRESULT CaseSensitive([out, retval] VARIANT_BOOL *IsCaseSensitive);
	[propput, helpstring("Whether or not lookups are case sensitive")]
	HRESULT CaseSensitive([in] VARIANT_BOOL IsCaseSensitive);

	// Methods
	[helpstring("Lookup a label based on name or address")]
	HRESULT Find([in] VARIANT Criteria, [out, retval] ILabel **Label);
	[helpstring("Loads labels from a file")]
	HRESULT Load([in] BSTR FileName);
}

[
	helpstring("Code execution breakpoint that can be enabled/disabled"),
	uuid(569FD80A-BAFB-4DA8-98EB-F83AFDBAC8B3),
	dual,
	pointer_default(unique)
]
interface IBreakpoint : IDispatch
{
	[propget]
	HRESULT Address([out, retval] ICalcAddress **Address);
	
	[propget]
	HRESULT Enabled([out, retval] VARIANT_BOOL *Enabled);
	[propput]
	HRESULT Enabled([in] VARIANT_BOOL Enabled);
}


[
	helpstring("Collection for managing breakpoints"),
	version(1.0),
	uuid(1A6B7029-87C3-4922-860B-D1971958DE4A),
	dual,
	pointer_default(unique)
]
interface IBreakpointCollection : IDispatch
{
	[propget]
	HRESULT Count([out, retval] LONG *Count);

	[id(DISPID_VALUE), propget]
	HRESULT Item([in] LONG Index, [out, retval] IBreakpoint **Item);

	[id(DISPID_NEWENUM), propget]
	HRESULT _NewEnum([out, retval] IUnknown** ppEnum);

	[helpstring("Add a new breakpoint")]
	HRESULT Add([in] ICalcAddress *Address, [out, retval] IBreakpoint **Breakpoint);

	[helpstring("Remove a breakpoint")]
	HRESULT Remove([in] IBreakpoint *Breakpoint);
}

[
	version(1.0),
	uuid(74950913-4DC9-4F68-AD0A-E5B5A4E0294D),
	dual,
	pointer_default(unique)
]
interface IMemoryContext : IDispatch
{
	[propget]
	HRESULT RAM([out, retval] SAFEARRAY(IPage *) *RAM);

	[propget]
	HRESULT Flash([out, retval] SAFEARRAY(IPage *) *Flash);

	[propget]
	HRESULT Bank([out, retval] SAFEARRAY(IPage *) *Flash);

	[helpstring("Read from memory")]
	HRESULT Read([in] WORD Address, [in, optional] VARIANT Count, [out, retval] VARIANT *Value);

	[helpstring("Write to memory")]
	HRESULT Write([in] WORD Address, [in] VARIANT Value);
};


const int DISPID_BREAKPOINT = 1;

[
	version(1.0),
	uuid(C349A6C5-D650-4F8B-961B-81470999F813)
]
dispinterface DWabbitemuEvents
{
properties:
methods:
	[id(DISPID_BREAKPOINT)] HRESULT Breakpoint(IBreakpoint *Breakpoint);
};

[
	uuid(020FB9D5-7F45-449b-B9DF-66CFC2482BD0),
	object,
	version(1.0),
	oleautomation
]
interface IWabbitemu : IDispatch
{
	[propget, helpstring("Whether or not the UI is visible.")]
	HRESULT Visible([out, retval] VARIANT_BOOL *lpVisible); 
	[propput, helpstring("Whether or not the UI is visible.")]
	HRESULT Visible([in] VARIANT_BOOL fVisible); 

	[propget, helpstring("The Z80 CPU of the calculator.")] 
	HRESULT CPU([out, retval] IZ80 **ppZ80);

	[propget, helpstring("The memory of the calculator")]
	HRESULT Memory([out, retval] IMemoryContext **Memory);

	[propget, helpstring("The LCD device of the calculator.")]
	HRESULT LCD([out, retval] ILCD **ppLCD);

	[propget, helpstring("Whether or not the calculator is running.")]
	HRESULT Running([out, retval] VARIANT_BOOL *lpfRunning);

	[helpstring("Execute a single instruction")]
	HRESULT Step();
	HRESULT StepOver();
	HRESULT Run();
	HRESULT Break();

	[propget, helpstring("Collection of execution breakpoints")]
	HRESULT Breakpoints([out, retval] IBreakpointCollection **Breakpoints);

	HRESULT LoadFile([in] BSTR FileName);

	[propget, helpstring("List of applications on the calculator.")]
	HRESULT Apps([out, retval] SAFEARRAY(struct TIApplication) *AppList);

	//[propget, helpstring("List of symbols (programs, lists, etc) on the calculator.")]
	//HRESULT Symbols([out, retval] SAFEARRAY(struct TISymbol) *SymList);

	[propget, helpstring("Gets the keypad device on the calculator.")]
	HRESULT Keypad([out, retval] IKeypad **Keypad);
	
	[propget, helpstring("Gets the list of labels loaded on this calculator.")]
	HRESULT Labels([out, retval] ILabelServer **Labels);
};

[
	uuid(EDA903F6-7BB8-437f-978F-8F1A2B8B65DB),
	helpstring("Wabbitemu Type Library 1.0"),
	version(1.0),
]
library WabbitemuLib
{
	importlib("stdole32.tlb");

	interface IBank;
	interface ILCD;
	dispinterface DWabbitemuEvents;

	[
		uuid(1A03AFA2-C9C7-4d5b-9732-D78011D5009B)
	]
	coclass Wabbitemu
	{
		[default] interface IWabbitemu;
		[default, source] dispinterface DWabbitemuEvents;
	}

	[
		uuid(D46A319B-86C3-4F4C-8F7F-8189C38B62EC)
	]
	coclass CalcAddress
	{
		[default] interface ICalcAddress;
	}
};
