using System;
using System.Collections;
using System.IO;
using System.Xml;
using Revsoft.Wabbitcode.Properties;
using Revsoft.Wabbitcode.Services;
using System.Collections.Generic;
using System.Text;
using System.Windows;
using Revsoft.Wabbitcode.Services.Parser;

namespace Revsoft.Wabbitcode.Services.Project
{
    public class ProjectClass : IProject
    {
        /// <summary>
        /// Root directory that the project resides in.
        /// </summary>
        public string ProjectDirectory { get; private set; }

        /// <summary>
        /// Location of the actual XML file of the project. 
        /// Normally located in $(ProjectDirectory)\$(ProjectName).wcodeproj
        /// </summary>
        public string ProjectFile { get; private set; }

        private ProjectFolder mainFolder;
        /// <summary>
        /// Root folder of the virtual folder wabbitcode uses to keep track of files
        /// </summary>
        public ProjectFolder MainFolder { get { return mainFolder; } set { mainFolder = value;} }

        /// <summary>
        /// Name of the project
        /// </summary>
        public string ProjectName { get; set; }

        /// <summary>
        /// Whether we've made changes to the project file that need to be saved
        /// </summary>
        public bool NeedsSave { get; set; }

        /// <summary>
        /// Class for building the project. Contains the build configs and each build step is contained within them
        /// </summary>
        public BuildSystem BuildSystem { get; private set; }

        /// <summary>
        /// List of information generated by our parser about each file
        /// </summary>
        public IList<ParserInformation> ParseInfo { get; private set; }

        /// <summary>
        /// List of all the paths to include when building so files are properly found
        /// </summary>
        public List<string> IncludeDirs { get; set; }

        /// <summary>
        /// List of all the exe files the project outputs
        /// </summary>
		List<string> projectOutputs = new List<string>();
		public List<string> ProjectOutputs
		{
			get { return projectOutputs; }
		}

        /// <summary>
        /// List of all the listing files the project outputs
        /// </summary>
		List<string> listOutputs = new List<string>();
		public List<string> ListOutputs
		{
			get { return listOutputs; }
		}

        /// <summary>
        /// List of all the label files the project outputs
        /// </summary>
		List<string> labelOutputs = new List<string>();
		public List<string> LabelOutputs
		{
			get { return labelOutputs; }
		}

        /// <summary>
        /// Indicates whether the projects actually exists as a file on disk or 
        /// only in memory for wabbitcode to manage
        /// </summary>
        public bool IsInternal { get; set; }

		public ProjectClass() 
        {
            BuildSystem = new BuildSystem(this, false);
            this.ParseInfo = new List<ParserInformation>();
            this.IncludeDirs = new List<string>();
        }

        public ProjectClass(string projectFile)
        {
            this.BuildSystem = new BuildSystem(this, false);
			this.IsInternal = false;
			this.ProjectFile = projectFile;
            this.IncludeDirs = new List<string>();
			this.ProjectDirectory = Path.GetDirectoryName(projectFile);
            this.ParseInfo = new List<ParserInformation>();

            if (Settings.Default.StartupProject != projectFile)
                if (MessageBox.Show("Would you like to make this your default project?", "Startup Project",
                                    MessageBoxButton.YesNo, MessageBoxImage.Question) == MessageBoxResult.Yes)
                    Settings.Default.StartupProject = projectFile;
        }

		internal void CreateNewProject(string projectFile, string projectName)
		{
			ProjectFolder folder = new ProjectFolder(this, projectName);
			this.mainFolder = folder;
			this.ProjectName = projectName;
			this.ProjectFile = projectFile;
			this.ProjectDirectory = Path.GetDirectoryName(projectFile);
			this.BuildSystem = new BuildSystem(this, true);
		}

		internal void OpenProject(string projectFile)
		{
			FileStream stream = new FileStream(projectFile, FileMode.Open);
			XmlTextReader reader = new XmlTextReader(stream);
			reader.WhitespaceHandling = WhitespaceHandling.None;
			reader.MoveToContent();
			while (!reader.Name.Equals("WabbitcodeProject"))
			{
				if (!reader.MoveToNextElement())
					throw new InvalidDataException("Invalid XML Format");
			}

			string formatVersion = reader.GetAttribute("Version");
			if (formatVersion != ProjectFileVersion && 
                MessageBox.Show("Project Version is not up to date.\nTry to load anyway?", "Invalid Version", MessageBoxButton.YesNo) != MessageBoxResult.Yes)
				return;
			ProjectName = reader.GetAttribute("Name");
			reader.MoveToNextElement();
			if (reader.Name != "Folder")
				throw new ArgumentException("Invalid XML Format");
			mainFolder = new ProjectFolder(this, reader.GetAttribute("Name"));
			RecurseReadFolders(reader, ref mainFolder);
			BuildSystem.ReadXML(reader);
			reader.Close();
			stream.Close();
		}

        #region XML
        private void RecurseReadFolders(XmlTextReader reader, ref ProjectFolder folder)
		{
			if (reader.IsEmptyElement)
				return;
			while (reader.Read())
			{
				if (reader.NodeType == XmlNodeType.EndElement)
					return;
				if (reader.Name == "Folder")
				{
					ProjectFolder subFolder = new ProjectFolder(this, reader.GetAttribute("Name"));
					folder.AddFolder(subFolder);
					RecurseReadFolders(reader, ref subFolder);
				}
				else if (reader.Name == "File")
				{
					ProjectFile file = new ProjectFile(this, reader.GetAttribute("Path"));
					folder.AddFile(file);
				} 
				else
					return;
			}
			
		}

		const string ProjectFileVersion = "1.0";
		internal void BuildXMLFile()
		{
			XmlTextWriter writer = new XmlTextWriter(ProjectFile, Encoding.Unicode);
			writer.Formatting = Formatting.Indented;
			writer.WriteStartDocument();
			writer.WriteComment("Wabbitcode Config File");
			writer.WriteStartElement("WabbitcodeProject");
			writer.WriteAttributeString("Version", ProjectFileVersion);
			writer.WriteAttributeString("Name", ProjectName);
			RecurseWriteFolders(writer, mainFolder);
			BuildSystem.CreateXML(writer);
			writer.WriteEndElement();
			writer.Flush();
			writer.Close();
		}

		private void RecurseWriteFolders(XmlTextWriter writer, ProjectFolder folder)
		{
			writer.WriteStartElement("Folder");
			writer.WriteAttributeString("Name", folder.Name);
			foreach (ProjectFolder subFolder in folder.Folders)
				RecurseWriteFolders(writer, subFolder);
			foreach (ProjectFile file in folder.Files)
			{
				writer.WriteStartElement("File");
				writer.WriteAttributeString("Path", file.FileRelativePath);
				writer.WriteAttributeString("Foldings", file.FileFoldings);
				writer.WriteEndElement();
			}
			writer.WriteEndElement();
		}
        #endregion
        
        internal List<ProjectFile> GetProjectFiles()
		{
			List<ProjectFile> files = new List<ProjectFile>();
			RecurseAddFiles(ref files, mainFolder);
			return files;
		}

		private void RecurseAddFiles(ref List<ProjectFile> files, ProjectFolder folder)
		{
			foreach (ProjectFolder subFolder in folder.Folders)
				RecurseAddFiles(ref files, subFolder);
			foreach (ProjectFile file in folder.Files)
				files.Add(file);
		}


        #region Virtual File Management
        public ProjectFolder AddFolder(string dirName, ProjectFolder parentFolder)
        {
            ProjectFolder folder = new ProjectFolder(this, dirName);
            parentFolder.AddFolder(folder);
            return folder;
        }

        public ProjectFile AddFile(ProjectFolder parentFolder, string fullPath)
        {
            ProjectFile file = new ProjectFile(this, fullPath);
            parentFolder.AddFile(file);
            return file;
        }

        public void DeleteFolder(ProjectFolder parentDir, ProjectFolder dir)
        {
            parentDir.Folders.Remove(dir);
        }

        public void DeleteFile(string fullPath)
        {
            ProjectFile file = FindFile(fullPath);
            DeleteFile(file);
            NeedsSave = true;
        }

        public void DeleteFile(ProjectFile file)
        {
            file.Remove();
        }

        public bool ContainsFile(string fullPath)
        {
            fileFound = null;
            return RecurseSearchFolders(mainFolder, Path.GetFileName(fullPath));
        }
        #endregion

        private ProjectFile fileFound;
        private bool RecurseSearchFolders(ProjectFolder folder, string file)
        {
            if (fileFound == null)
                fileFound = folder.FindFile(file);
            if (fileFound != null)
                return true;
            bool returnVal = false;
            foreach (ProjectFolder subFolder in folder.Folders)
                returnVal |= RecurseSearchFolders(subFolder, file);
            if (fileFound != null)
                return true;
            return returnVal;
        }

        public ProjectFile FindFile(string fullPath)
        {
            if (fileFound != null && fileFound.FileFullPath == fullPath)
                return fileFound;
            fileFound = null;
            if (ContainsFile(fullPath))
                return fileFound;
            return null;
        }

        public enum AssemblerOutputType
        {
            Bin,
            Program73,
            Program82,
            Program83,
            Program83p,
            App83p,
            Program85,
            String85,
            Program86,
            String86,
        }

        internal AssemblerOutputType GetOutputType()
        {
            foreach (IBuildStep step in BuildSystem.CurrentConfig.Steps)
            {
                if (step.GetType() == typeof(InternalBuildStep))
                {
                    InternalBuildStep iStep = (InternalBuildStep)step;
                    string outputFile = iStep.OutputFile;
                    string ext = Path.GetExtension(outputFile);
                    if (ext == ".8xk")
                        return AssemblerOutputType.App83p;
                    if (ext == ".8xp")
                        return AssemblerOutputType.Program83p;
                }
            }
            //otherwise we assume its a bin
            return AssemblerOutputType.Bin;
        }

        internal ParserInformation GetParseInfo(string fullPath)
        {
            foreach (ParserInformation info in ParseInfo)
                if (info.SourceFile.ToLower() == fullPath.ToLower())
                    return info;
            return null;
        }
    }
}
